
1.单例模式的优点：
	在内存中只有一个对象，节省内存空间。
	避免频繁的创建销毁对象，可以提高性能。
	避免对共享资源的多重占用。
	可以全局访问。

2.适用场景：
	需要频繁实例化然后销毁的对象。
	创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
	有状态的工具类对象。
	频繁访问数据库或文件的对象。
	以及其他我没用过的所有要求只有一个对象的场景。

3.单例模式注意事项：
	只能使用单例类提供的方法得到单例对象，不要使用反射，否则将会实例化一个新对象。
	不要做断开单例类对象与类中静态引用的危险操作。
	多线程使用单例使用共享资源时，注意线程安全问题。
	
	
4.懒汉模式下的三种加载方式：
	第1种，在方法调用上加了同步，虽然线程安全了，但是每次都要同步，会影响性能，毕竟99%的情况下是不需要同步的，
	
	第2种，在getInstance中做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗
	
	第3种，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，所以一般我倾向于使用这一种。


注意：double check不是线程安全的，如果要用这种方式，需要使用volatile关键字。
5.	假设没有关键字volatile的情况下，两个线程A、B，都是第一次调用该单例方法，线程A先执行instance = new Instance()，
	该构造方法是一个非原子操作，编译后生成多条字节码指令，由于JAVA的指令重排序，可能会先执行instance的赋值操作，
	该操作实际只是在内存中开辟一片存储对象的区域后直接返回内存的引用，之后instance便不为空了，但是实际的初始化操作却还没有执行，
	如果就在此时线程B进入，就会看到一个不为空的但是不完整（没有完成初始化）的Instance对象，所以需要加入volatile关键字，禁止指令重排序优化，
	从而安全的实现单例。
	
创建对象可以分解为如下的3行伪代码
	memory=allocate(); //1:分配对象的内存空间
	ctorInstance(memory); //2:初始化对象
	instance=memory; //3:设置instance指向刚分配的内存地址上面3行代码中的2和3之间，可能会被重排序导致先3后2,



